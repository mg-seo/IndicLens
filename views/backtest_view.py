from __future__ import annotations

import json
from typing import Tuple

import pandas as pd
import plotly.graph_objects as go
import streamlit as st

# ÏÇ¨Ïö©Ïûê Ï†úÍ≥µ Î™®Îìà (IndicLens/backtest/*)
from backtest import data as d
from backtest import signals as sig
from backtest import engine as eng
from backtest import evals as ev

from ui.sidebar import Inputs, now_utc

# ‚îÄ‚îÄ Ï∫êÏãú ÏÑ§Ï†ï ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
CACHE_TTL_PRICE = 600   # 10Î∂Ñ


@st.cache_data(show_spinner=False, ttl=CACHE_TTL_PRICE)
def load_price(symbol: str, interval: str, months: int) -> pd.DataFrame:
    """ÏÑ†Î¨º Ï∫îÎì§ ÌéòÏπò(Í∏∞Í∞Ñ: months). Ï∫êÏãúÎê®."""
    end = pd.Timestamp(now_utc())
    start = end - pd.DateOffset(months=int(months))
    df = d.fetch_futures_klines_range(symbol, interval, start, end)
    return df


# ‚îÄ‚îÄ Î£∞ ÎπåÎçî ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
_SAMPLE_SET = {
    "name": "ÏÉòÌîå: RSI 30‚Üó Îß§Ïàò / 70‚Üò Îß§ÎèÑ",
    "entry": {
        "op": "crossover",
        "left": {"name": "rsi", "params": {"period": 14}},
        "right": {"type": "const", "value": 30},
    },
    "exit": {
        "op": "crossunder",
        "left": {"name": "rsi", "params": {"period": 14}},
        "right": {"type": "const", "value": 70},
    },
}


# Ï¢å/Ïö∞ Ïä§ÏºÄÏùº Íµ¨Î∂Ñ: Ïú†Ìö®Ìïú ÎπÑÍµêÎßå UIÏóê Ï†úÍ≥µÌïòÍ∏∞ ÏúÑÌï®
#   - price Í≥ÑÏó¥: close, sma, ema, bbands.*
#   - rsi Í≥ÑÏó¥: rsi
#   - macd Í≥ÑÏó¥: macd.macd / macd.signal / macd.hist

def _scale_of(base: str) -> str:
    if base in ("close", "sma", "ema"):
        return "price"
    if base.startswith("bbands"):
        return "price"
    if base == "rsi":
        return "rsi"
    if base.startswith("macd"):
        return "macd"
    return "unknown"


def _indicator(name: str, span: int | None = None, window: int | None = None, field: str | None = None):
    obj = {"name": name}
    params = {}
    if span is not None:
        params["span"] = int(span)
    if window is not None:
        params["window"] = int(window)
    if params:
        obj["params"] = params
    if field:
        obj["field"] = field
    return obj


def _build_left(base: str, p1: int):
    if base.startswith("macd"):
        # macd ÌïÑÎìúÎäî Ïò§Î•∏Ï™Ω ÎπÑÍµêÏö©ÏóêÏÑúÎßå ÏÇ¨Ïö©ÌïòÎØÄÎ°ú, ÏôºÏ™ΩÏóêÏÑú macd.ÌïÑÎìúÎ•º Í≥†Î•¥Î©¥ Ìï¥Îãπ ÌïÑÎìúÎ•º Î™ÖÏãú
        field = base.split(".")[1]
        return _indicator("macd", field=field)
    if base.startswith("bbands"):
        field = base.split(".")[1]
        return _indicator("bbands", window=p1, field=field)
    if base == "sma":
        return _indicator("sma", window=p1)
    if base == "ema":
        return _indicator("ema", span=p1)
    if base == "rsi":
        return {"name": "rsi", "params": {"period": int(p1)}}
    return {"name": base}


def _rule_builder_ui() -> tuple[dict | None, dict | None]:
    st.subheader("üß± Î£∞ ÎπåÎçî")
    with st.expander("Í∏∞Î≥∏ ÏßÄÌëúÎ°ú Ï°∞Í±¥ ÎßåÎì§Í∏∞", expanded=False):
        # 1) ÏôºÏ™Ω(Ï£ºÏù∏Í≥µ) ÏÑ†ÌÉù
        col1, col2 = st.columns(2)
        with col1:
            kind = st.selectbox(
                "Ï°∞Í±¥ Ïú†Ìòï",
                ["crossover", "crossunder", "compare"],
                help="crossover/crossunder: ÏôºÏ™ΩÏù¥ Ïò§Î•∏Ï™ΩÏùÑ ÏúÑ/ÏïÑÎûòÎ°ú ÌÜµÍ≥ºÌïòÎäî ÏàúÍ∞Ñ. compare: Îã®Ïàú ÎπÑÍµê",
            )
            base = st.selectbox(
                "ÏôºÏ™Ω(Ï£ºÏù∏Í≥µ): ÏßÄÌëú/ÏÜåÏä§",
                [
                    "close", "sma", "ema", "rsi",
                    "macd.macd", "macd.signal", "macd.hist",
                    "bbands.bb_upper", "bbands.bb_mid", "bbands.bb_lower",
                ],
                help="ÏôºÏ™ΩÏùÄ Ïã†Ìò∏Ïùò Ï£ºÏù∏Í≥µ. Ïù¥ Í∞íÏù¥ Í∏∞Ï§ÄÏÑ†(Ïò§Î•∏Ï™Ω)ÏùÑ ÎÑòÎäîÏßÄ/ÏïÑÎãåÏßÄ Í≤ÄÏÇ¨Ìï©ÎãàÎã§.",
            )
            p1 = st.number_input("ÏôºÏ™Ω Í∏∞Í∞Ñ(window/period)", 1, 300, 14,
                                  help="sma/ema/rsi/bbandsÏóê ÏÇ¨Ïö©. macd/closeÎäî Î¨¥Ïãú")
        left_scale = _scale_of(base if base else "")

        # 2) Ïò§Î•∏Ï™Ω(Í∏∞Ï§ÄÏÑ†) ÏÑ†ÌÉù ‚Äî ÏôºÏ™ΩÏùò Ïä§ÏºÄÏùºÏóê ÎßûÏ∂∞ ÏòµÏÖò Ï†úÌïú
        with col2:
            if left_scale == "rsi":
                right_choice = st.selectbox(
                    "Ïò§Î•∏Ï™Ω(Í∏∞Ï§ÄÏÑ†)", ["ÏÉÅÏàò", "rsi"], index=0,
                    help="RSIÎäî ÏÉÅÏàò(30/70 Îì±) ÎòêÎäî RSI(Í∏∞Í∞Ñ Îã§Î•¥Í≤å)ÏôÄ ÎπÑÍµêÌïòÎäî Í≤å ÏùòÎØ∏ ÏûàÏäµÎãàÎã§.",
                )
            elif left_scale == "macd":
                right_choice = st.selectbox(
                    "Ïò§Î•∏Ï™Ω(Í∏∞Ï§ÄÏÑ†)", ["ÏÉÅÏàò", "macd.macd", "macd.signal", "macd.hist"], index=1,
                    help="MACDÎäî Ïã†Ìò∏ÏÑ†Í≥ºÏùò ÍµêÏ∞®(macd vs signal) ÎòêÎäî 0ÏÑ†Í≥ºÏùò ÍµêÏ∞®(ÏÉÅÏàò 0) Îì±Ïù¥ ÏùºÎ∞òÏ†Å.",
                )
            else:  # price Í≥ÑÏó¥ (close/sma/ema/bbands)
                right_choice = st.selectbox(
                    "Ïò§Î•∏Ï™Ω(Í∏∞Ï§ÄÏÑ†)",
                    ["close", "sma", "ema", "bbands.bb_upper", "bbands.bb_mid", "bbands.bb_lower"],
                    index=2,
                    help="Í∞ÄÍ≤© Ïä§ÏºÄÏùºÎÅºÎ¶¨ ÎπÑÍµê. Ïòà) close > ema(20), sma(20) crossover sma(50)",
                )

            # Ïò§Î•∏Ï™Ω ÌååÎùºÎØ∏ÌÑ∞ ÏûÖÎ†•(ÏÑ†ÌÉùÏóê Îî∞Îùº Îã§Î¶Ñ)
            thr = None
            p2 = None
            if right_choice == "ÏÉÅÏàò":
                thr = st.number_input(
                    "Ïò§Î•∏Ï™Ω ÏÉÅÏàòÍ∞í",
                    value=0.0,
                    help="RSI 30/70, MACD 0ÏÑ† Îì±. Í∞ÄÍ≤©ÏóêÎäî ÏÉÅÏàò ÏûÑÍ≥ÑÍ∞íÏùÑ Ïûò Ïì∞ÏßÄ ÏïäÏäµÎãàÎã§.",
                )
            elif right_choice in ("sma", "ema"):
                p2 = st.number_input("Ïò§Î•∏Ï™Ω Í∏∞Í∞Ñ(window/span)", 1, 300, 20,
                                      help="sma/emaÏùò Í∏∏Ïù¥")
            elif right_choice.startswith("bbands"):
                p2 = st.number_input("Ïò§Î•∏Ï™Ω BBANDS Í∏∞Í∞Ñ(window)", 1, 300, 20,
                                      help="Î≥ºÎ¶∞Ï†ÄÎ∞¥Îìú Ï§ëÏã¨ÏÑ† Í∏∞Í∞Ñ")
            elif right_choice == "rsi":
                p2 = st.number_input("Ïò§Î•∏Ï™Ω RSI Í∏∞Í∞Ñ(period)", 1, 300, 14,
                                      help="ÏôºÏ™Ω RSIÏôÄ Îã§Î•∏ Í∏∞Í∞ÑÏúºÎ°ú ÎπÑÍµê Í∞ÄÎä•")

        # 3) Ï¢å/Ïö∞ Ïã§Ï†ú Í∞ùÏ≤¥ Íµ¨ÏÑ±
        left = _build_left(base, p1)
        # Ïò§Î•∏Ï™Ω Íµ¨ÏÑ±
        if right_choice == "ÏÉÅÏàò":
            right = {"type": "const", "value": thr if thr is not None else 0.0}
        elif right_choice == "sma":
            right = _indicator("sma", window=int(p2))
        elif right_choice == "ema":
            right = _indicator("ema", span=int(p2))
        elif right_choice == "rsi":
            right = {"name": "rsi", "params": {"period": int(p2) if p2 else 14}}
        elif right_choice.startswith("bbands"):
            field = right_choice.split(".")[1]
            right = _indicator("bbands", window=int(p2), field=field)
        elif right_choice.startswith("macd"):
            field = right_choice.split(".")[1]
            right = _indicator("macd", field=field)
        else:  # close
            right = {"name": right_choice}

        # 4) ÏµúÏ¢Ö ÌëúÌòÑÏãù
        if kind in ("crossover", "crossunder"):
            base_expr = {"op": kind, "left": left, "right": right}
        else:
            comp = st.selectbox("ÎπÑÍµê Ïó∞ÏÇ∞Ïûê", [">", "<", ">=", "<=", "==", "!="], index=1,
                                help="compare Î™®ÎìúÏóêÏÑúÎßå ÏÇ¨Ïö©")
            base_expr = {"op": comp, "left": left, "right": right}

        st.code(json.dumps(base_expr, ensure_ascii=False, indent=2), language="json")

        use_for = st.radio("Ïù¥ Ï°∞Í±¥ÏùÑ Ïñ¥ÎîîÏóê ÏÇ¨Ïö©Ìï†Íπå?", ["Îß§Ïàò(Entry)", "Îß§ÎèÑ(Exit)"], horizontal=True)
        entry_expr = base_expr if use_for == "Îß§Ïàò(Entry)" else None
        exit_expr = base_expr if use_for == "Îß§ÎèÑ(Exit)" else None

        if st.button("Ï°∞Í±¥ ÏÑ∏Ìä∏Ïóê Ï∂îÍ∞Ä"):
            if "condition_sets" not in st.session_state:
                st.session_state.condition_sets = [_SAMPLE_SET]
            st.session_state.condition_sets.append({
                "name": f"ÏÇ¨Ïö©Ïûê Ï°∞Í±¥ #{len(st.session_state.condition_sets)}",
                "entry": entry_expr or _SAMPLE_SET["entry"],
                "exit": exit_expr or _SAMPLE_SET["exit"],
            })
            st.success("Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§. ÏïÑÎûò 'Ï°∞Í±¥ Î¶¨Ïä§Ìä∏'ÏóêÏÑú ÏÑ†ÌÉùÌï¥ Î∞±ÌÖåÏä§Ìä∏!")

    return None, None


def _ensure_state():
    if "condition_sets" not in st.session_state:
        st.session_state.condition_sets = [_SAMPLE_SET]


def _conditions_ui():
    st.subheader("üìã Ï°∞Í±¥ Î¶¨Ïä§Ìä∏")
    names = [c["name"] for c in st.session_state.condition_sets]
    chosen = st.multiselect("Î∞±ÌÖåÏä§Ìä∏Ìï† Ï°∞Í±¥ ÏÑ∏Ìä∏ ÏÑ†ÌÉù (Î≥µÏàò ÏÑ†ÌÉù Í∞ÄÎä•)", names, default=names[:1])
    comb = st.radio("Ïó¨Îü¨ Ï°∞Í±¥ÏùÑ Ïñ¥Îñ§ Î∞©ÏãùÏúºÎ°ú Ìï©Ïπ†Íπå?", ["and", "or"], horizontal=True)
    return chosen, comb


def _combine_rules(selected_names: list[str], comb: str) -> tuple[dict, dict]:
    chosen = [c for c in st.session_state.condition_sets if c["name"] in selected_names]
    if not chosen:
        chosen = [st.session_state.condition_sets[0]]
    entry_rules = [c["entry"] for c in chosen]
    exit_rules = [c["exit"] for c in chosen]
    if len(entry_rules) == 1:
        entry = entry_rules[0]
        exit_ = exit_rules[0]
    else:
        entry = {"op": comb, "args": entry_rules}
        exit_ = {"op": comb, "args": exit_rules}
    return entry, exit_


def _plot_equity(price_df: pd.DataFrame, curves: dict[str, pd.Series]):
    fig = go.Figure()
    for name, eq in curves.items():
        fig.add_trace(go.Scatter(x=price_df["time"], y=eq, mode="lines", name=name))
    fig.update_layout(
        title="Ï†ÑÎûµÎ≥Ñ ÏóêÏøºÌã∞ Í≥°ÏÑ† (Ï¥àÍ∏∞ 1.0)",
        hovermode="x unified",
        xaxis=dict(showspikes=True, spikemode="across", spikesnap="cursor"),
        yaxis_title="Equity",
        margin=dict(t=40, b=10, l=10, r=10),
        height=420,
    )
    st.plotly_chart(fig, use_container_width=True)


def view(inputs: Inputs):
    _ensure_state()

    # 1) Îç∞Ïù¥ÌÑ∞ Î°úÎìú (Ï∫êÏãú)
    price_df = load_price(inputs.symbol, inputs.interval, inputs.months)
    if price_df.empty:
        st.error("Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§.")
        return

    # 2) Î£∞ ÎπåÎçî UI
    _rule_builder_ui()

    # 3) Ï°∞Í±¥ Î¶¨Ïä§Ìä∏ & Ï°∞Ìï© Î∞©Ïãù
    selected, comb = _conditions_ui()
    entry_rule, exit_rule = _combine_rules(selected, comb)

    # 4) Î∞±ÌÖåÏä§Ìä∏ Ïã§Ìñâ
    entry_sig = sig.evaluate_rule(entry_rule, price_df)
    exit_sig = sig.evaluate_rule(exit_rule, price_df)

    bt_df, trades, trade_log = eng.backtest_long_only(
        price_df, entry_sig, exit_sig, fee=inputs.fee, slippage=inputs.slippage, cooldown=0
    )

    # Buy&Hold Í≥°ÏÑ†
    bh = price_df["close"] / price_df["close"].iloc[0]

    # 5) ÏÑ±Í≥º ÏöîÏïΩ
    periods_per_year = {"15m": 4*24*365, "1h": 24*365, "4h": 6*365, "1d": 365}[inputs.interval]
    summary = ev.summarize(bt_df["equity"], trades, periods_per_year)
    st.markdown("### üìà ÏÑ±Í≥º ÏöîÏïΩ")
    st.dataframe(pd.DataFrame([summary]), use_container_width=True)

    # 6) Í∑∏ÎûòÌîÑ
    _plot_equity(price_df, {"Ï†ÑÎûµ": bt_df["equity"], "Buy&Hold": bh})

    with st.expander("üßæ Ï≤¥Í≤∞ Î°úÍ∑∏"):
        st.dataframe(pd.DataFrame(trade_log))
